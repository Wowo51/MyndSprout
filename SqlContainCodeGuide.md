Of course. Here is a long-form guide for using the `SqlContain` library.

This guide provides a comprehensive overview of the `SqlContain` library, a .NET tool designed to secure and isolate SQL Server instances. You'll learn how to use it to reduce the attack surface of your database, making it safer for applications, especially in environments where SQL commands might be generated by AI or other automated systems.

-----

## Introduction to SqlContain

`SqlContain` is a .NET library designed to **harden** a Microsoft SQL Server instance and its databases. Hardening is the process of reducing a system's vulnerabilities by minimizing its attack surface. This library is particularly useful when you need to execute SQL commands against a database from a source you don't fully trust, such as a large language model (LLM) or an AI agent.

By systematically disabling dangerous features, revoking risky permissions, and installing security triggers, `SqlContain` creates a sandboxed environment where SQL operations are restricted to standard data manipulation and schema management, preventing actions that could compromise the host system.

The library's core functions include:

  * Disabling potentially harmful instance-level features like `xp_cmdshell`, CLR integration, and OLE Automation.
  * Denying broad, high-risk permissions from the `public` role, such as creating CLR assemblies or external data sources.
  * Creating server-level and database-level DDL triggers to block the creation of unsafe objects like linked servers and credentials in real time.
  * Optionally applying a strict Windows Firewall rule to prevent the SQL Server process from making any outbound network calls.

-----

## Getting Started

Using `SqlContain` is straightforward. You configure your desired security settings, connect to the server with administrative privileges, and run the hardener.

### Prerequisites

1.  **.NET Project:** You need a .NET project where you can add the `SqlContain` library.
2.  **SQL Server Instance:** Access to a SQL Server instance (like a local `(LocalDB)\MSSQLLocalDB` or a dedicated server) is required.
3.  **Sysadmin Privileges:** The login used to run the hardener **must be a member of the `sysadmin` server role**. This is necessary to change instance configurations and create server-level triggers.

### Configuration with `HardenerOptions`

All hardening operations are controlled through the `HardenerOptions` class. This is where you define what to harden and how.

```csharp
using SqlContain;

var options = new HardenerOptions
{
    // Connection Details
    Server = "(LocalDB)\\MSSQLLocalDB",
    Auth = "Trusted", // or "Sql"
    // User = "your_sql_user",   // Required if Auth = "Sql"
    // Password = "your_password", // Required if Auth = "Sql"

    // Target and Scope
    Scope = Scope.Both, // Harden both the Instance and a specific Database
    Database = "MyHardenedDb",

    // Advanced Features
    Firewall = true,
    SqlServrPath = @"C:\Program Files\Microsoft SQL Server\MSSQL16.MSSQLSERVER\MSSQL\Binn\sqlservr.exe",

    // Compatibility Flags
    AllowSkippedDeny = false,
    AllowMissingTrigger = false,
    DisallowUse = true
};
```

#### Key `HardenerOptions` Properties:

  * **Connection (`Server`, `Auth`, etc.):** Standard SQL connection parameters. `"Trusted"` uses Windows Authentication.
  * **`Scope`:** This is the most important setting. It can be:
      * `Scope.Instance`: Applies server-wide configurations (`sp_configure`) and a server-level trigger.
      * `Scope.Database`: Applies database-specific settings (`DENY` statements, `TRUSTWORTHY OFF`) and a database-level trigger to the database specified in the `Database` property.
      * `Scope.Both`: Applies both instance and database hardening.
  * **`Database`:** The name of the specific database you want to harden. This is **required** if the `Scope` is `Database` or `Both`.
  * **`Firewall`:** If `true`, the library will attempt to add a Windows Firewall rule to block all outbound network traffic from the SQL Server process. This requires the application to be run with **administrator privileges** (it will trigger a UAC prompt if not already elevated).
  * **`SqlServrPath`:** The full path to the `sqlservr.exe` executable. This is **required** if `Firewall` is set to `true`.
  * **`AllowSkippedDeny`:** Defaults to `false`. If `true`, it allows the hardening process to continue even if some `DENY` statements fail (e.g., on an older SQL Server version that doesn't recognize a specific permission). For maximum security, leave this as `false`.
  * **`DisallowUse`:** Defaults to `true`. When enabled, the internal SQL executor prevents the execution of `USE [SomeOtherDatabase];` statements, ensuring operations are strictly confined to the intended database.

-----

## Running the Hardener

The main entry point is the static `Hardener.RunAsync` method. It takes your configured options and an optional logging action.

### Example 1: Hardening a Single Database

This is the most common scenario. You have a database, and you want to lock it down.

```csharp
using SqlContain;
using System;
using System.Threading.Tasks;

public class Program
{
    public static async Task Main()
    {
        var options = new HardenerOptions
        {
            Server = "(LocalDB)\\MSSQLLocalDB",
            Auth = "Trusted",
            Scope = Scope.Database,
            Database = "MyAgentDb" // Ensure this database exists first
        };

        Console.WriteLine($"Hardening database '{options.Database}'...");

        try
        {
            int resultCode = await Hardener.RunAsync(options, logMessage => Console.WriteLine(logMessage));

            if (resultCode == 0)
            {
                Console.WriteLine("Hardening completed successfully!");
            }
            else
            {
                Console.WriteLine("Hardening failed.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred: {ex.Message}");
        }
    }
}
```

### Example 2: Hardening an Instance and Adding a Firewall Rule

This example applies server-wide settings and then adds the restrictive firewall rule. Remember, this requires running the application as an administrator.

```csharp
var options = new HardenerOptions
{
    Server = "(LocalDB)\\MSSQLLocalDB",
    Auth = "Trusted",
    Scope = Scope.Instance,
    Firewall = true,
    SqlServrPath = @"C:\Program Files\Microsoft SQL Server\MSSQL15.MSSQLLOCALDB\MSSQL\Binn\sqlservr.exe"
};

Console.WriteLine("Hardening instance and applying firewall rule...");
Console.WriteLine("A UAC prompt may appear to grant administrator rights for the firewall change.");

int resultCode = await Hardener.RunAsync(options, logMessage => Console.WriteLine(logMessage));

if (resultCode == 0)
{
    Console.WriteLine("Instance hardening and firewall configuration complete.");
}
```

### Handling Errors

`Hardener.RunAsync` returns an integer result code (`0` for success). However, it will throw exceptions for more serious failures. It's common to see an `AggregateException` if one or more `DENY` statements fail and `AllowSkippedDeny` is `false`. You can inspect the exception's `Data` dictionary for detailed diagnostics.

```csharp
try
{
    await Hardener.RunAsync(options, Console.WriteLine);
}
catch (AggregateException aggEx)
{
    Console.WriteLine("One or more hardening steps failed.");
    if (aggEx.Data.Contains("SkippedDeny"))
    {
        var skipped = aggEx.Data["SkippedDeny"] as IReadOnlyCollection<string>;
        Console.WriteLine("The following DENY statements were skipped:");
        foreach (var deny in skipped ?? Enumerable.Empty<string>())
        {
            Console.WriteLine($"- {deny}");
        }
    }
    // Log the full exception for details
    Console.WriteLine(aggEx);
}
catch (Exception ex)
{
    Console.WriteLine($"A critical error occurred: {ex.Message}");
}
```

-----

## Security Mechanisms Explained

`SqlContain` uses a layered approach to security.

#### 1\. Instance Configuration (`ServerHardener`)

When you use `Scope.Instance` or `Scope.Both`, the hardener connects to the `master` database and executes `sp_configure` to disable features that could allow the database engine to interact with the underlying operating system or network. This includes:

  * `xp_cmdshell`: Prevents executing command-line shells.
  * `Ole Automation Procedures`: Disables COM object instantiation.
  * `clr enabled`: Disables the execution of .NET code inside SQL Server.
  * `external scripts enabled`: Blocks Python/R scripts.

#### 2\. Permission Revocation (`DatabaseHardener`)

For `Scope.Database` or `Scope.Both`, the hardener applies a series of `DENY` statements to the `public` role within the target database. This prevents any user from performing high-risk actions like:

  * `CREATE ASSEMBLY`
  * `CREATE CREDENTIAL`
  * `ALTER ANY EXTERNAL DATA SOURCE`
  * `ALTER ANY EXTERNAL LIBRARY`
  * `ALTER ANY EXTERNAL FILE FORMAT`

#### 3\. Proactive Blocking with DDL Triggers

`DENY` statements are great, but triggers provide an active defense. `SqlContain` creates triggers that fire on certain DDL (Data Definition Language) events and immediately roll back the transaction.

  * **Server Trigger:** Blocks `CREATE_LINKED_SERVER` and `CREATE_CREDENTIAL` across the entire instance.
  * **Database Trigger:** Blocks `CREATE_ASSEMBLY`, `CREATE_CREDENTIAL`, and other external resource operations within the specific database. This trigger is dynamically built by probing the target SQL Server version to see which DDL events it actually supports, making it more resilient.

#### 4\. Network Isolation (`FirewallService`)

The optional firewall rule is the outermost layer of defense. By blocking all **outbound** traffic from `sqlservr.exe`, it ensures that even if an attacker finds a way to execute code within the SQL Server process, that code cannot "phone home" or exfiltrate data over the network.